# modules/drivers/exploit/auth_driver.py

import os
from typing import Optional
import requests
from http.cookiejar import MozillaCookieJar

from core.driver import BaseToolDriver, DriverResult, ParsedResult

class AuthDriver(BaseToolDriver):
    """
    AuthDriver handles HTTP form-based login for targets that require authentication.
    It uses the shared requests.Session from SessionManager so that subsequent
    drivers (form discovery, sqlmap, etc.) carry the login cookies automatically.
    """

    name = "auth"

    def __init__(self, config: dict, session_mgr, logger):
        super().__init__(config, session_mgr, logger)
        # Where to dump cookies in Netscape/Mozilla format
        self.cookie_dir = config.get("cookie_output_dir", "results/raw/cookies")
        os.makedirs(self.cookie_dir, exist_ok=True)

    def run(self, target: str, **kwargs) -> DriverResult:
        """
        Perform login on the target if credentials are provided.
        Expects config["auth_credentials"][target] to exist with keys:
          - login_url: full URL to POST login form
          - username_field: form field name for the user (e.g. "username")
          - password_field: form field name for the pass (e.g. "password")
          - username: login username
          - password: login password

        On success, saves a cookie jar to:
           {cookie_dir}/{safe_target}.txt
        """
        creds = self.config.get("auth_credentials", {}).get(target)
        if not creds:
            self.logger.info(f"[AuthDriver] No credentials for {target}; skipping login")
            return DriverResult(raw_output=None)

        session: requests.Session = self.session_mgr.get(target)

        login_url       = creds.get("login_url")
        user_field      = creds.get("username_field", "username")
        pass_field      = creds.get("password_field", "password")
        username        = creds.get("username")
        password        = creds.get("password")

        if not all([login_url, username, password]):
            raise RuntimeError(f"[AuthDriver] Incomplete creds for {target}")

        # Build form data
        form_data = {
            user_field: username,
            pass_field: password
        }

        self.logger.info(f"[AuthDriver] Logging into {target} via {login_url}")
        resp = session.post(login_url, data=form_data, timeout=30)
        if resp.status_code not in (200, 302):
            raise RuntimeError(f"[AuthDriver] Login failed for {target}: HTTP {resp.status_code}")

        # Save cookies in Netscape format for external tools
        safe_target = target.replace("://", "_").replace("/", "_")
        cookie_path = os.path.join(self.cookie_dir, f"{safe_target}.txt")
        jar = MozillaCookieJar(cookie_path)
        # Transfer cookies from requests.Session into our jar
        for ck in session.cookies:
            jar.set_cookie(ck)
        jar.save(ignore_discard=True, ignore_expires=True)
        self.logger.info(f"[AuthDriver] Saved cookies to {cookie_path}")

        return DriverResult(raw_output=cookie_path)

    def parse(self, raw_output: Optional[str]) -> ParsedResult:
        """
        No parsing needed for auth; downstream drivers use session_mgr directly.
        We return an empty dict to satisfy the interface.
        """
        return ParsedResult(data={})
