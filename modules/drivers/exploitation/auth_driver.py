# modules/drivers/exploit/auth_driver.py
import re
import os
from typing import Optional
import requests
from http.cookiejar import MozillaCookieJar

from  modules.core.driver import BaseToolDriver, DriverResult, ParsedResult
class DVWAAuthDriver:
    def __init__(self, base_url, username, password, logger=None):
        self.base_url = base_url.rstrip("/")
        self.username = username
        self.password = password
        self.logger = logger
        self.session = requests.Session()
        self.phpsessid = None

    def login(self):
        login_url = f"{self.base_url}/login.php"
        # 1. Get login page, try to extract CSRF token if present
        r = self.session.get(login_url, verify=False)
        token = None
        m = re.search(r'name="user_token" value="([a-f0-9]+)"', r.text)
        if m:
            token = m.group(1)
            if self.logger:
                self.logger.info(f"CSRF token: {token}")

        # 2. Prepare login data
        data = {
            "username": self.username,
            "password": self.password,
            "Login": "Login"
        }
        if token:
            data["user_token"] = token

        # 3. POST login
        resp = self.session.post(login_url, data=data, verify=False)
        if "Login failed" in resp.text or "Username and/or password incorrect." in resp.text:
            if self.logger:
                self.logger.error("Login failed.")
            return False

        # 4. Extract session cookie
        cookies = self.session.cookies.get_dict()
        self.phpsessid = cookies.get("PHPSESSID")
        if self.logger:
            self.logger.info(f"PHPSESSID: {self.phpsessid}")
        return self.phpsessid is not None

    def get_session(self):
        return self.session

    def get_cookie(self):
        return self.phpsessid
class AuthDriver(BaseToolDriver):
    """
    AuthDriver handles HTTP form-based login for targets that require authentication.
    It uses the shared requests.Session from SessionManager so that subsequent
    drivers (form discovery, sqlmap, etc.) carry the login cookies automatically.
    """

    name = "auth"

    def __init__(self, config: dict, session_mgr, logger):
        super().__init__(config, session_mgr, logger)
        # Where to dump cookies in Netscape/Mozilla format
        self.cookie_dir = config.get("cookie_output_dir", "results/raw/cookies")
        os.makedirs(self.cookie_dir, exist_ok=True)

    def run(self, target: str, **kwargs) -> DriverResult:
        """
        Perform login on the target if credentials are provided.
        Expects config["auth_credentials"][target] to exist with keys:
        - login_url: full URL to POST login form
        - username_field: form field name for the user (e.g. "username")
        - password_field: form field name for the pass (e.g. "password")
        - username: login username
        - password: login password

        On success, saves a cookie jar to:
        {cookie_dir}/{safe_target}.txt
        """
        creds = self.config.get("auth_credentials", {}).get(target)
        if not creds:
            raise RuntimeError(f"[AuthDriver] No credentials for {target}")

        session: requests.Session = self.session_mgr.get(target)

        login_url   = creds.get("login_url")
        user_field  = creds.get("username_field", "username")
        pass_field  = creds.get("password_field", "password")
        username    = creds.get("username")
        password    = creds.get("password")

        if not all([login_url, username, password]):
            raise RuntimeError(f"[AuthDriver] Incomplete creds for {target}")

        # Build form data
        form_data = {
            user_field: username,
            pass_field: password
        }

        self.logger.info(f"[AuthDriver] Logging into {target} via {login_url}")
        resp = session.post(login_url, data=form_data, timeout=30)
        if resp.status_code not in (200, 302):
            raise RuntimeError(f"[AuthDriver] Login failed for {target}: HTTP {resp.status_code}")

        # Save cookies in Netscape format for external tools
        safe_target = target.replace("://", "_").replace("/", "_")
        cookie_path = os.path.join(self.cookie_dir, f"{safe_target}.txt")
        jar = MozillaCookieJar(cookie_path)
        for ck in session.cookies:
            jar.set_cookie(ck)
        jar.save(ignore_discard=True, ignore_expires=True)
        self.logger.info(f"[AuthDriver] Saved cookies to {cookie_path}")

        return DriverResult(raw_output=cookie_path)


    def parse(self, raw_output: Optional[str]) -> ParsedResult:
        """
        No parsing needed for auth; downstream drivers use session_mgr directly.
        We return an empty dict to satisfy the interface.
        """
        return ParsedResult(data={})
