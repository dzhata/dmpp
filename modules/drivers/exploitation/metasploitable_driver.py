import os
import subprocess
import logging
import socket

from modules.core.driver import BaseToolDriver, DriverResult, ParsedResult
from modules.drivers.exploitation.generate_rc import generate_msf_resource_scripts
from modules.core.utils import safe_filename

class MetasploitDriver(BaseToolDriver):
    """
    Runs Metasploit msfconsole with a generated resource script for automation.
    Saves raw msfconsole output for later parsing.
    """
    name = "metasploit"

    def __init__(self, config: dict, session_mgr, logger: logging.Logger):
        super().__init__(config, session_mgr, logger)
        self.msf_path = config.get("metasploit_path", "msfconsole")
        self.resource_dir = config.get("metasploit_resource_dir", "modules/drivers/exploitation/msf_scripts")
        self.output_dir = config.get("metasploit_output_dir", "results/raw/metasploit")
        os.makedirs(self.output_dir, exist_ok=True)

        # Try to get LHOST from config or fallback to local IP
        self.lhost = config.get("lhost") or self._get_local_ip()

    def _get_local_ip(self):
        # Basic method to auto-detect local IP (can be improved)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    def run(self, target: str, **kwargs) -> DriverResult:
        """
        Generate and run msfconsole with a target-specific resource script.
        """
        safe_target = safe_filename(target)
        rc_path = os.path.join(self.resource_dir, f"{safe_target}.rc")

        # Always (re)generate the resource script for this target
        generate_msf_resource_scripts([target], self.lhost, output_dir=self.resource_dir)

        if not os.path.exists(rc_path):
            raise RuntimeError(f"Failed to generate resource script for {target} ({rc_path})")

        output_path = os.path.join(self.output_dir, f"{safe_target}.txt")
        cmd = [
            self.msf_path,
            "-r", rc_path,
            "-q"  # Quiet: less banner output
        ]
        with open(output_path, "w") as f:
            proc = subprocess.run(
                cmd,
                stdout=f,
                stderr=subprocess.STDOUT,
                timeout=self.config.get("scan_timeout_sec", 600)
            )
        if proc.returncode != 0:
            self.logger.error(f"[MetasploitDriver] Error running msfconsole for {target}")
        else:
            self.logger.info(f"[MetasploitDriver] Output saved to {output_path}")
        return DriverResult(raw_output=output_path)

    def parse(self, raw_output_path: str) -> ParsedResult:
        """
        Simple parse: look for session creation, exploit success/failure in msfconsole output.
        """
        results = {"exploits": [], "sessions": []}
        try:
            with open(raw_output_path) as f:
                for line in f:
                    if "Meterpreter session" in line or "Command shell session" in line:
                        results["sessions"].append(line.strip())
                    if "[*] Exploit completed" in line or "No active sessions" in line:
                        results["exploits"].append(line.strip())
        except Exception as e:
            self.logger.error(f"[MetasploitDriver] Failed to parse output: {e}")
        return ParsedResult(data=results)
